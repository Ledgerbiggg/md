# 数据结构与算法

# 基础数据结构
* 数组 
* 链表  
* 递归
* 队列
* 栈
* 堆
* 二叉树

# 查找算法
## 二分查找
```java
public static int binarySearch(int[] a,int target){
        int i=0;
        int j=a.length-1;
        while (i<=j){
            int m = (i + j) / 2;
            int num= a[m];
            if(num>target){
                j=m-1;
            }else if (num<target){
                i=m+1;
            }else {
                return m;
            }
        }
        return -1;
    }
```
* 问题所在:
    * 数组越界问题(i+j)/2超出整数范围变成负数
    * 修改写法
```java
    public static int binarySearch2(int[] a,int target){
        int i=0;
        int j=a.length-1;
        while (i<=j){
            int m = (i + j) >>> 1;
            int num= a[m];
            if(num>target){
                j=m-1;
            }else if (num<target){
                i=m+1;
            }else {
                return m;
            }
        }
        return -1;
    }
```
* 相同的写法
```java
    public static int binarySearch2(int[] a,int target){
        int i=0;
        int j=a.length;
        while (i<j){                //L
            int m = (i + j) >>> 1;  //L
            int num= a[m];          //L
            if(num>target){         //L
                j=m;                //L
            }else if (num<target){
                i=m+1;
            }else {
                return m;
            }
        }
        return -1;
    }
```
* 二分查找算法最糟糕的情况下执行次数
> floor(log_2(n)+1)*5 + 4

### 时间复杂度(渐进上界)
* 使用大O表示法,表示最差的一种情况$O(n)$

* 二分查找法的用法时间复杂度是  $log_2n$使用大O表示法$O(log_2n)$

* 从低到高
1. $O(1)$
2. $O(log(n))$

3. $O(n)$
4. $O(nlog(n))$

5. $O(n^2)$
5. $O(2^n)$
6. $O(n!)$


### 时间复杂度(渐进下界)

### 时间复杂度(渐进紧界)

### 空间复杂度(大O表示法)
* 定义
    * 一个算法随着数据规模增大,增长的**额外**空间成本


* 二分查找额外占用的空间$O(1)$


### 总结
* 二分查找的性能
> 时间复杂度
* 最坏情况$O(logn)$ 没查到
* 最好情况$O(1)$ 最中间

> 空间复杂度
* $O(1)$ 额外空间为常数

### 平衡板
* 变种
```java
    public static int binarySearch3(int[] a, int target) {
        int i = 0;
        int j = a.length;
        while (1 < j - i) {
            int m = (i + j) >>> 1;
            int num = a[m];
            if (num < target) {
                j = m;
            } else {
                i = m;
            }
        }
        if (a[i] == target) {
            return i;
        }
        return -1;
    }
```
* java中找不到数字之后,返回
```java
    private static int binarySearch0(int[] a, int fromIndex, int toIndex,int key) {
        int low = fromIndex;
        int high = toIndex - 1;

        while (low <= high) {
            int mid = (low + high) >>> 1;
            int midVal = a[mid];

            if (midVal < key)
                low = mid + 1;
            else if (midVal > key)
                high = mid - 1;
            else
                return mid; // key found
        }
        return -(low + 1);  // key not found. 插入点减一(加一取反变成插入点)
}
```
### 插入没有的元素
```java
 public static int[] insert() {
        int[] arr = {1, 2, 3};
        int target = 10;
        int i = Arrays.binarySearch(arr, target);
        int[] arr2 = new int[arr.length + 1];
        if (i < 0) {
            int insertIndex = Math.abs(i + 1);
            // 从源数组的索引 0 处开始复制，复制 insertIndex 个元素到目标数组的索引 0 处
            System.arraycopy(arr, 0, arr2, 0, insertIndex);
            arr2[insertIndex] = target;
            System.arraycopy(arr, insertIndex, arr2, insertIndex + 1, arr.length - insertIndex);
        }
        return arr2;
    }
```


























































































































